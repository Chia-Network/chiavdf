#include "verifier.h"
#include "create_discriminant.h"

void assertm(bool expr, std::string msg, bool verbose=false) {
    if (expr && verbose) {
        std::cout << "Assertion passed." << std::endl;
    } else if (!expr) {
        std::cout << "Assertion " << msg << " failed." << std::endl;
    }
}

std::vector<uint8_t> HexToBytes(const char *hex_proof) {
    int len = strlen(hex_proof);
    assert(len % 2 == 0);
    std::vector<uint8_t> result;
    for (int i = 0; i < len; i += 2)
    {
        int hex1 = hex_proof[i] >= 'a' ? (hex_proof[i] - 'a' + 10) : (hex_proof[i] - '0');
        int hex2 = hex_proof[i + 1] >= 'a' ? (hex_proof[i + 1] - 'a' + 10) : (hex_proof[i + 1] - '0');
        result.push_back(hex1 * 16 + hex2);
    }
    return result;
}

int main()
{
        bool is_valid = CheckProofOfTimeNWesolowski(
            integer("-104302725420488446041064177827908260116644368412127111058803074924075031463297295086805423548090978945084412601721724605944765665700125371784022089538205879786969892706808180204178049308680096357022588020734806047890020109569282086270242660932514867521655819779406971323521332542199453903461211372358921026719"),
            integer("2"),
            integer("1"),
            &(HexToBytes((const char *)"001dd8279ad3072bb4cf8f3d756c85ff78928974b7ac1e93740a0b96f9fadb3b4e0728d3d78574d5828f7737d7a48541ea268329eedbe540f2dca88426d686b081fff27ba070ba4931d56bd4e4ccb7c22f5a767ebc8936b1da07147e1576c84acffac5373e93f8acb9f4d334760a53af180bbab177c26d567520224b18e67161cbdd003a8ba5f1c71085a29ba13ecfc23274ff0db7de02b92cbfc25e58e089e5f6eb82cce5399000fadf4eb887b35da6a1f9867e70fc8479fc18a216989d23d5c902bcfff83a8fd24491e55ef51dce90c48c1e207989589229dfba304cc7f055141399d8696a9ce563de7ced05fdc275a8627d3c85e4fc4dc78d0cacf10df128116762b90000000000202b2800267aee78ec65b836767ca98beda2b0c4be09f56cb88ff2b6abe152138bfa61efa4a0b941d0cc980050e08b89e14c96231a47a61e906af7068b67a49c7c39e23c00076be9cffc601b9785ffeaaa0c733d35a6bb359174979889285146f69cbabd0c34c67131d4e4e111f517ff0cfae187ddce552061fee3c16bffb1184d53e1b377003fa5f21f4ee8fb93e46e11843c7b85412c8862b8df9eb4c437c87aa3686f369074ab67c4929e401f1cadb9f3f6f2383af44a3ef0e2622a461d6180666c09dbf2ffde2709da943eb77c6ec7faaffee3aac29429e42ebf784a8e8be8713ba89bc655512f601bfa280cab4303fe2c009b2c4599681ec11a30a25a9d694abf695095eb00000000006081140041d4cf23dcfa2e52fab5abf2b1f65c23fff172e963604f65563550514cbab4ddaf25f5db1174513800dc7872be8a0a3b67f5ad628e17b6b0530a6b54ff83f014ffd82a401900a518356c2c86f1a3961b40e73959e5bb228fe98fe925b41fbc6cf71fb0eabf36a885701c9fe0859c2bf905b8ea60488890ddb5fd88566407cd3cc7000ea4eb2a57afd520ebd6dcca7c1e3cb1341bd8c75d3399e476208ead684668a1a2ffa2d3698879c89ab3be776558269e7f30fa953c9a48764df27ce538c7f6c6fff72fb8230cd5e3de1ff3b85b809d60a8aa40da67cf200cd149d94b1821e7cb31cfc38e132052f9b061c806110885fccfe4fb7521752eb99d234a66e36d945991")[0]),
            strlen("001dd8279ad3072bb4cf8f3d756c85ff78928974b7ac1e93740a0b96f9fadb3b4e0728d3d78574d5828f7737d7a48541ea268329eedbe540f2dca88426d686b081fff27ba070ba4931d56bd4e4ccb7c22f5a767ebc8936b1da07147e1576c84acffac5373e93f8acb9f4d334760a53af180bbab177c26d567520224b18e67161cbdd003a8ba5f1c71085a29ba13ecfc23274ff0db7de02b92cbfc25e58e089e5f6eb82cce5399000fadf4eb887b35da6a1f9867e70fc8479fc18a216989d23d5c902bcfff83a8fd24491e55ef51dce90c48c1e207989589229dfba304cc7f055141399d8696a9ce563de7ced05fdc275a8627d3c85e4fc4dc78d0cacf10df128116762b90000000000202b2800267aee78ec65b836767ca98beda2b0c4be09f56cb88ff2b6abe152138bfa61efa4a0b941d0cc980050e08b89e14c96231a47a61e906af7068b67a49c7c39e23c00076be9cffc601b9785ffeaaa0c733d35a6bb359174979889285146f69cbabd0c34c67131d4e4e111f517ff0cfae187ddce552061fee3c16bffb1184d53e1b377003fa5f21f4ee8fb93e46e11843c7b85412c8862b8df9eb4c437c87aa3686f369074ab67c4929e401f1cadb9f3f6f2383af44a3ef0e2622a461d6180666c09dbf2ffde2709da943eb77c6ec7faaffee3aac29429e42ebf784a8e8be8713ba89bc655512f601bfa280cab4303fe2c009b2c4599681ec11a30a25a9d694abf695095eb00000000006081140041d4cf23dcfa2e52fab5abf2b1f65c23fff172e963604f65563550514cbab4ddaf25f5db1174513800dc7872be8a0a3b67f5ad628e17b6b0530a6b54ff83f014ffd82a401900a518356c2c86f1a3961b40e73959e5bb228fe98fe925b41fbc6cf71fb0eabf36a885701c9fe0859c2bf905b8ea60488890ddb5fd88566407cd3cc7000ea4eb2a57afd520ebd6dcca7c1e3cb1341bd8c75d3399e476208ead684668a1a2ffa2d3698879c89ab3be776558269e7f30fa953c9a48764df27ce538c7f6c6fff72fb8230cd5e3de1ff3b85b809d60a8aa40da67cf200cd149d94b1821e7cb31cfc38e132052f9b061c806110885fccfe4fb7521752eb99d234a66e36d945991")/2,
            9486887,
            1024,
            2);

    auto challenge_hash1 = HexToBytes(string("a4bb1461ade74ac602e9ae511af68bb254dfe65d61b7faf9fab82d0b4364a30b").data());
    auto challenge_hash2 = HexToBytes(string("1633f29c0ca0597258507bc7d323a8bd485d5f059da56340a2c616081fb05b7f").data());
    auto challenge_hash3 = HexToBytes(string("6aa2451d1469e1213e50f114a49744f96073fedbe53921c8294a303779baa32d").data());

    // Create Discriminant tests
    for (auto seed: {challenge_hash1, challenge_hash2, challenge_hash3}) {
        integer D = CreateDiscriminant(seed, 1024);
        integer P = D * integer(-1);
        assertm(mpz_tstbit(P.impl, 1023) == 1, "1023-th bit should be set");
        assertm(P < (integer(1) << 1024), "P should be at most 1024 bits");
        assertm(D % integer(8) == integer(1), "D should be 1 mod 8");
        assertm(P.prime(), "P should be psuedoprime");
    }

    return 0;
}
