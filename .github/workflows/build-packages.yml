name: VDF client & HW CI

on:
  push:
    branches:
      - main
  release:
    types: [published]
  pull_request:
    branches:
      - '**'
  workflow_dispatch:
    inputs:
      macos_notarize:
        description: "Notarize macOS bundles (requires Apple signing + notarization secrets)"
        required: false
        default: false
        type: boolean

concurrency:
  # SHA is added to the end if on `main` to let all main workflows run
  group: ${{ github.ref }}-${{ github.workflow }}-${{ github.event_name }}-${{ (github.ref == 'refs/heads/main' || startsWith(github.ref, 'refs/heads/release/') || startsWith(github.ref, 'refs/heads/long_lived/')) && github.sha || '' }}
  cancel-in-progress: true

permissions:
  id-token: write
  contents: write

env:
  CHIAVDF_LOG_AVX: "1"

jobs:
  build:
    name: CI (${{ matrix.os }}, ${{ matrix.config }})
    runs-on: ${{ matrix.os }}
    env:
      # Runtime feature gate read via getenv() in parameters.h.
      # Keep this at job scope so all test/bench steps see it.
      CHIA_ENABLE_AVX512_IFMA: "1"
      # On release workflows, pin embedded CLI version to the tag.
      RELEASE_TAG: ${{ github.event_name == 'release' && github.event.release.tag_name || '' }}
    strategy:
      fail-fast: false
      matrix:
        os: [ubuntu-latest, ubuntu-24.04-arm, macos-13-intel, macos-13-arm64, windows-latest]
        config: [optimized=1, TSAN=1, ASAN=1]
        exclude:
          - os: windows-latest
            config: ASAN=1
          - os: windows-latest
            config: TSAN=1

    steps:
      - name: Checkout code
        uses: actions/checkout@v6

      - name: Install Python
        uses: Chia-Network/actions/setup-python@main
        with:
          python-version: "3.10"

      - name: Set Env
        uses: Chia-Network/actions/setjobenv@main
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Test for Apple signing secrets
        if: startsWith(matrix.os, 'macos') && matrix.config == 'optimized=1'
        id: check_secrets
        shell: bash
        run: |
          unset HAS_APPLE_SECRET
          unset HAS_NOTARIZE_SECRETS
          if [ -n "$APPLE_SECRET" ]; then HAS_APPLE_SECRET='true'; fi
          if [ -n "$APPLE_NOTARIZE_USERNAME" ] && [ -n "$APPLE_NOTARIZE_PASSWORD" ] && [ -n "$APPLE_TEAM_ID" ]; then
            HAS_NOTARIZE_SECRETS='true'
          fi
          echo "HAS_APPLE_SECRET=${HAS_APPLE_SECRET}" >> "$GITHUB_OUTPUT"
          echo "HAS_NOTARIZE_SECRETS=${HAS_NOTARIZE_SECRETS}" >> "$GITHUB_OUTPUT"
        env:
          APPLE_SECRET: "${{ secrets.APPLE_DEV_ID_APP }}"
          APPLE_NOTARIZE_USERNAME: "${{ secrets.APPLE_NOTARIZE_USERNAME }}"
          APPLE_NOTARIZE_PASSWORD: "${{ secrets.APPLE_NOTARIZE_PASSWORD }}"
          APPLE_TEAM_ID: "${{ secrets.APPLE_TEAM_ID }}"

      - name: Delete keychain if it already exists
        if: startsWith(matrix.os, 'macos') && matrix.config == 'optimized=1' && steps.check_secrets.outputs.HAS_APPLE_SECRET == 'true'
        run: security delete-keychain signing_temp.keychain || true

      - name: Import Apple app signing certificate
        if: startsWith(matrix.os, 'macos') && matrix.config == 'optimized=1' && steps.check_secrets.outputs.HAS_APPLE_SECRET == 'true'
        uses: Apple-Actions/import-codesign-certs@v6
        with:
          p12-file-base64: ${{ secrets.APPLE_DEV_ID_APP }}
          p12-password: ${{ secrets.APPLE_DEV_ID_APP_PASS }}

      - name: Install macOS deps (build + runtime)
        if: startsWith(matrix.os, 'macos')
        run: |
          brew ls --versions cmake >/dev/null 2>&1 || brew install cmake
          # Keep gmp installed for CI builds/tests; Homebrew formulas must also
          # declare gmp as a runtime dependency for end-user installs.
          brew ls --versions gmp >/dev/null 2>&1 || brew install gmp
          brew ls --versions boost >/dev/null 2>&1 || brew install boost
          echo "DYLD_FALLBACK_LIBRARY_PATH=$(brew --prefix gmp)/lib:${DYLD_FALLBACK_LIBRARY_PATH:-}" >> "$GITHUB_ENV"

      # Runtime workaround for TSAN-instrumented binaries on Ubuntu runners.
      # Apply before build because make TSAN=1 runs ./compile_asm during build.
      # See: https://github.com/google/sanitizers/issues/1716
      - name: Adjust mmap_rnd_bits before Ubuntu TSAN build/test execution
        if: startsWith(matrix.os, 'ubuntu') && matrix.config == 'TSAN=1'
        run: |
          sudo sysctl vm.mmap_rnd_bits=28

      - name: Build on Ubuntu
        if: startsWith(matrix.os, 'ubuntu')
        run: |
          # Keep mmap_rnd_bits workaround step above this build for TSAN=1:
          # make TSAN=1 executes thread-sanitized ./compile_asm during build.
          sudo apt-get update -y -o Acquire::Retries=3
          sudo apt-get install -y build-essential cmake libgmp-dev libboost-python-dev libpython3-dev libboost-system-dev
          ./scripts/get-libft4222.sh install
          cd src
          if [ -n "$RELEASE_TAG" ]; then
            make ${{ matrix.config }} CHIAVDF_VERSION="$RELEASE_TAG" -f Makefile.vdf-client vdf_client vdf_bench 1weso_test 2weso_test prover_test emu_hw_test hw_test emu_hw_vdf_client hw_vdf_client
          else
            make ${{ matrix.config }} -f Makefile.vdf-client vdf_client vdf_bench 1weso_test 2weso_test prover_test emu_hw_test hw_test emu_hw_vdf_client hw_vdf_client
          fi

      - name: Build on macOS
        if: startsWith(matrix.os, 'macos')
        run: |
          BOOST_VERSION="$(brew list --versions boost | awk '{print $2}')"
          BOOST_INCLUDE=""
          for cand in \
            "$(brew --prefix boost)/include" \
            "$(brew --prefix)/include" \
            "$(brew --cellar boost)/${BOOST_VERSION}/include"; do
            if [ -f "$cand/boost/asio.hpp" ]; then
              BOOST_INCLUDE="$cand"
              break
            fi
          done
          if [ -z "$BOOST_INCLUDE" ]; then
            echo "Could not locate boost/asio.hpp for brew boost=${BOOST_VERSION}" >&2
            brew --prefix boost || true
            brew --cellar boost || true
            brew info boost || true
            exit 1
          fi
          ./scripts/get-libft4222.sh install
          cd src
          if [ -n "$RELEASE_TAG" ]; then
            make ${{ matrix.config }} CHIAVDF_VERSION="$RELEASE_TAG" CPPFLAGS="-I${BOOST_INCLUDE} ${CPPFLAGS:-}" -f Makefile.vdf-client vdf_client vdf_bench 1weso_test 2weso_test prover_test emu_hw_test hw_test emu_hw_vdf_client hw_vdf_client
          else
            make ${{ matrix.config }} CPPFLAGS="-I${BOOST_INCLUDE} ${CPPFLAGS:-}" -f Makefile.vdf-client vdf_client vdf_bench 1weso_test 2weso_test prover_test emu_hw_test hw_test emu_hw_vdf_client hw_vdf_client
          fi

      - name: Cache Boost on Windows
        if: matrix.os == 'windows-latest'
        id: cache-boost
        uses: actions/cache/restore@v5
        with:
          path: C:\local\boost_*
          key: windows-boost-msvc-14.3-v1

      - name: Cache mpir checkout on Windows
        if: matrix.os == 'windows-latest'
        id: cache-mpir
        uses: actions/cache@v5
        with:
          path: mpir_gc_x64
          key: windows-mpir-gc-x64-v1

      - name: Checkout mpir for Windows
        if: matrix.os == 'windows-latest' && steps.cache-mpir.outputs.cache-hit != 'true'
        uses: actions/checkout@v6
        with:
          repository: Chia-Network/mpir_gc_x64
          fetch-depth: 1
          path: mpir_gc_x64

      - name: Install LLVM, Ninja and Boost on Windows
        if: matrix.os == 'windows-latest'
        shell: pwsh
        env:
          BOOST_CACHE_HIT: ${{ steps.cache-boost.outputs.cache-hit }}
        run: |
          $llvmBin = "C:\Program Files\LLVM\bin\clang-cl.exe"
          $ninjaBin = "C:\ProgramData\chocolatey\bin\ninja.exe"
          if (-not (Test-Path $llvmBin) -or -not (Test-Path $ninjaBin)) {
            choco install llvm ninja -y
          }
          $boostDir = Get-ChildItem "C:\local" -Directory -Filter "boost_*" -ErrorAction SilentlyContinue | Select-Object -First 1
          if (-not $boostDir) {
            if ("$env:BOOST_CACHE_HIT" -ne "true") {
              Write-Host "Boost cache miss and boost not found, installing boost-msvc-14.3"
              choco install boost-msvc-14.3 -y
            } else {
              Write-Host "Boost cache reported hit but boost directory missing; reinstalling boost-msvc-14.3"
              choco install boost-msvc-14.3 -y
            }
            $boostDir = Get-ChildItem "C:\local" -Directory -Filter "boost_*" -ErrorAction SilentlyContinue | Select-Object -First 1
          } else {
            Write-Host "Boost already present at $($boostDir.FullName), skipping choco install"
          }
          "C:\Program Files\LLVM\bin" | Out-File -Append -FilePath $env:GITHUB_PATH
          if (-not $boostDir) {
            throw "Boost install not found under C:\local"
          }
          "BOOST_INCLUDE_DIR=$($boostDir.FullName)" | Out-File -Append -FilePath $env:GITHUB_ENV

      - name: Save Boost cache on Windows
        if: matrix.os == 'windows-latest' && steps.cache-boost.outputs.cache-hit != 'true'
        uses: actions/cache/save@v5
        with:
          path: C:\local\boost_*
          key: ${{ steps.cache-boost.outputs.cache-primary-key }}

      - name: Set up MSVC environment (Windows SDK + CRT libs)
        if: matrix.os == 'windows-latest'
        uses: ilammy/msvc-dev-cmd@v1
        with:
          arch: x64

      - name: Download USB drivers (FT4222H) on Windows
        if: matrix.os == 'windows-latest'
        run: powershell -ExecutionPolicy Bypass -File scripts/get-libft4222.ps1 install

      - name: Build on Windows
        if: matrix.os == 'windows-latest' && matrix.config == 'optimized=1'
        shell: pwsh
        run: |
          $cmakeArgs = @(
            "-S", "src",
            "-B", "build",
            "-G", "Ninja",
            "-DCMAKE_BUILD_TYPE=Release",
            "-DCMAKE_TRY_COMPILE_CONFIGURATION=Release",
            "-DCMAKE_MSVC_RUNTIME_LIBRARY=MultiThreadedDLL",
            "-DCMAKE_C_COMPILER=clang-cl",
            "-DCMAKE_CXX_COMPILER=clang-cl",
            "-DCMAKE_ASM_COMPILER=clang-cl",
            "-DBOOST_INCLUDE_DIR=$env:BOOST_INCLUDE_DIR",
            "-DBUILD_PYTHON=OFF",
            "-DBUILD_CHIAVDFC=OFF",
            "-DBUILD_VDF_CLIENT=ON",
            "-DBUILD_VDF_BENCH=ON",
            "-DBUILD_VDF_TESTS=ON",
            "-DBUILD_HW_TOOLS=ON",
            "-DENABLE_GNU_ASM=ON"
          )
          if ($env:RELEASE_TAG) {
            $cmakeArgs += "-DCHIAVDF_VERSION=$env:RELEASE_TAG"
          }
          & cmake @cmakeArgs
          $gnuAsmEnabled = (& cmake -N -L build | Select-String '^ENABLE_GNU_ASM:BOOL=ON$')
          if (-not $gnuAsmEnabled) {
            throw "ENABLE_GNU_ASM is not ON on Windows CI build"
          }
          cmake --build build --target vdf_client vdf_bench 1weso_test 2weso_test prover_test regression_unit_tests regression_io_tests emu_hw_test hw_test emu_hw_vdf_client hw_vdf_client
          if ($LASTEXITCODE -ne 0) {
            throw "Windows build failed with exit code $LASTEXITCODE"
          }
          $asmFiles = @("asm_compiled.s", "avx2_asm_compiled.s", "avx512_asm_compiled.s")
          foreach ($asmFile in $asmFiles) {
            # Depending on generator/layout, CMAKE_CURRENT_BINARY_DIR for src may resolve
            # to build/ or build/src/. Accept either location to avoid false negatives.
            $candidatePaths = @("build/$asmFile", "build/src/$asmFile")
            $foundPath = $candidatePaths | Where-Object { Test-Path $_ } | Select-Object -First 1
            if (-not $foundPath) {
              throw "Expected generated asm output not found in build/ or build/src/: $asmFile"
            }
            Write-Host "Verified generated asm output: $foundPath"
          }

      - name: Run HW smoke test (Ubuntu/macOS)
        if: matrix.os != 'windows-latest' && (matrix.config != 'TSAN=1' || startsWith(matrix.os, 'ubuntu'))
        run: |
          cd src
          # CI runners do not have FT4222 hardware attached; only validate binaries exist.
          test -x ./hw_vdf_client
          test -x ./hw_test
          echo "Running emu_hw_test"
          ./emu_hw_test 1 2000
          echo "Running emu_hw_vdf_client --list"
          ./emu_hw_vdf_client --list

      - name: Run vdf tests (optimized smoke)
        if: matrix.config == 'optimized=1' && matrix.os != 'windows-latest' && !startsWith(matrix.os, 'ubuntu')
        run: |
          cd src
          echo "Running 1weso_test (fast smoke)"
          ./1weso_test 1000
          echo "Running 2weso_test (fast smoke)"
          ./2weso_test 1000

      - name: Run vdf tests (optimized protected threshold path)
        if: matrix.config == 'optimized=1' && startsWith(matrix.os, 'ubuntu')
        run: |
          cd src
          echo "Running 1weso_test (fast smoke)"
          ./1weso_test 1000
          # 100 * 910000 = 91,000,000; this intentionally crosses the 2-weso switch threshold.
          echo "Running 2weso_test (protected threshold path)"
          ./2weso_test 910000

      - name: Run vdf tests (short)
        if: matrix.config != 'optimized=1' && matrix.os != 'windows-latest'
        run: |
          cd src
          echo "Running 1weso_test"
          ./1weso_test 1000
          echo "Running 2weso_test"
          ./2weso_test 1000

      # macos thread sanitizer will give false positives on ./prover_test because
      # it prints to std::cout from multiple threads. Which is allowed by the
      # standard
      - name: Run prover test (Ubuntu/macOS)
        if: matrix.os != 'windows-latest' && (matrix.config != 'TSAN=1' || startsWith(matrix.os, 'ubuntu'))
        run: |
          cd src
          echo "Running prover_test"
          if [[ "${{ matrix.os }}" == ubuntu* ]]; then
            ./prover_test
          else
            CHIAVDF_PROVER_TEST_FAST=1 ./prover_test
          fi

      - name: Run HW smoke test (Windows)
        if: matrix.os == 'windows-latest'
        shell: pwsh
        run: |
          cd build
          # Keep native stderr as log output; emu binaries log diagnostics there.
          $PSNativeCommandUseErrorActionPreference = $false
          $env:PATH = "$PWD;$PWD\..\src\hw\libft4222;$PWD\..\mpir_gc_x64;$env:PATH"
          # CI runners do not have FT4222 hardware attached; only validate binaries exist.
          if (-not (Test-Path ".\hw_test.exe")) { throw "hw_test.exe is missing" }
          if (-not (Test-Path ".\hw_vdf_client.exe")) { throw "hw_vdf_client.exe is missing" }
          Write-Host "Running emu_hw_test"
          .\emu_hw_test.exe 1 2000
          if ($LASTEXITCODE -ne 0) { throw "emu_hw_test failed with exit code $LASTEXITCODE" }
          Write-Host "Running emu_hw_vdf_client --list"
          .\emu_hw_vdf_client.exe --list
          if ($LASTEXITCODE -ne 0) { throw "emu_hw_vdf_client --list failed with exit code $LASTEXITCODE" }

      - name: Run vdf tests (Windows, optimized smoke)
        if: matrix.os == 'windows-latest' && matrix.config == 'optimized=1'
        shell: pwsh
        run: |
          cd build
          $env:PATH = "$PWD;$PWD\..\src\hw\libft4222;$PWD\..\mpir_gc_x64;$env:PATH"
          Write-Host "Running 1weso_test (fast smoke)"
          .\1weso_test.exe 1000
          if ($LASTEXITCODE -ne 0) { throw "1weso_test failed with exit code $LASTEXITCODE" }
          Write-Host "Running 2weso_test (fast smoke)"
          .\2weso_test.exe 1000
          if ($LASTEXITCODE -ne 0) { throw "2weso_test failed with exit code $LASTEXITCODE" }

      - name: Run prover test (Windows)
        if: matrix.os == 'windows-latest' && matrix.config == 'optimized=1'
        shell: pwsh
        run: |
          cd build
          $env:PATH = "$PWD;$PWD\..\src\hw\libft4222;$PWD\..\mpir_gc_x64;$env:PATH"
          Write-Host "Running prover_test"
          $env:CHIAVDF_PROVER_TEST_FAST = "1"
          .\prover_test.exe
          if ($LASTEXITCODE -ne 0) { throw "prover_test failed with exit code $LASTEXITCODE" }

      - name: Run GoogleTest regressions (Unix)
        if: matrix.config == 'optimized=1' && matrix.os != 'windows-latest'
        run: |
          cmake -S src -B build-regression -DBUILD_PYTHON=OFF -DBUILD_CHIAVDFC=OFF -DBUILD_VDF_CLIENT=OFF -DBUILD_VDF_BENCH=OFF -DBUILD_VDF_TESTS=ON -DBUILD_HW_TOOLS=OFF -DENABLE_GNU_ASM=ON
          cmake --build build-regression --target regression_unit_tests regression_io_tests
          ctest --test-dir build-regression --output-on-failure -R '^regression\.'

      - name: Run GoogleTest regressions (Windows)
        if: matrix.os == 'windows-latest' && matrix.config == 'optimized=1'
        shell: pwsh
        run: |
          cd build
          $env:PATH = "$PWD;$PWD\..\src\hw\libft4222;$PWD\..\mpir_gc_x64;$env:PATH"
          ctest -C Release --output-on-failure -R '^regression\.'

      - name: Benchmark vdf_bench square (Ubuntu/Mac)
        if: matrix.config == 'optimized=1' && matrix.os != 'windows-latest'
        run: |
          cd src
          echo "Benchmarking vdf_bench with 2,000,000 iterations of square_asm"
          ./vdf_bench square_asm 2000000

      - name: Benchmark vdf_bench square (Windows)
        if: matrix.config == 'optimized=1' && matrix.os == 'windows-latest'
        shell: pwsh
        run: |
          cd build
          $env:PATH = "$PWD;$PWD\..\src\hw\libft4222;$PWD\..\mpir_gc_x64;$env:PATH"
          Write-Host "Benchmarking vdf_bench with 2,000,000 iterations of square_asm"
          .\vdf_bench.exe square_asm 2000000
          if ($LASTEXITCODE -ne 0) { throw "vdf_bench failed with exit code $LASTEXITCODE" }

      - name: Assemble macOS brew bundle
        if: startsWith(matrix.os, 'macos') && matrix.config == 'optimized=1'
        env:
          RELEASE_TAG: ${{ github.event_name == 'release' && github.event.release.tag_name || format('0.0.1-{0}', github.run_id) }}
          IS_RELEASE: ${{ github.event_name == 'release' && 'true' || 'false' }}
          REQUEST_NOTARIZE: ${{ github.event_name == 'release' || (github.event_name == 'workflow_dispatch' && github.event.inputs.macos_notarize == 'true') }}
          HAS_APPLE_SECRET: ${{ steps.check_secrets.outputs.HAS_APPLE_SECRET || '' }}
          HAS_NOTARIZE_SECRETS: ${{ steps.check_secrets.outputs.HAS_NOTARIZE_SECRETS || '' }}
          APPLE_NOTARIZE_USERNAME: "${{ secrets.APPLE_NOTARIZE_USERNAME }}"
          APPLE_NOTARIZE_PASSWORD: "${{ secrets.APPLE_NOTARIZE_PASSWORD }}"
          APPLE_TEAM_ID: "${{ secrets.APPLE_TEAM_ID }}"
          NOTARIZE: ${{ (github.event_name == 'release' || (github.event_name == 'workflow_dispatch' && github.event.inputs.macos_notarize == 'true')) && steps.check_secrets.outputs.HAS_APPLE_SECRET == 'true' && steps.check_secrets.outputs.HAS_NOTARIZE_SECRETS == 'true' }}
        run: |
          set -euo pipefail

          if [ "${{ matrix.os }}" = "macos-13-arm64" ]; then
            MACOS_ARCH="arm64"
          else
            MACOS_ARCH="intel"
          fi
          BASE_NAME="chiavdf-${RELEASE_TAG}-macos-${MACOS_ARCH}"
          if [ "$REQUEST_NOTARIZE" = "true" ] && [ "$HAS_APPLE_SECRET" != "true" ]; then
            echo "Notarization requires Apple signing certificate secrets (APPLE_DEV_ID_APP/APPLE_DEV_ID_APP_PASS)." >&2
            exit 1
          fi
          if [ "$REQUEST_NOTARIZE" = "true" ] && [ "$HAS_NOTARIZE_SECRETS" != "true" ]; then
            echo "Notarization requires secrets (APPLE_NOTARIZE_USERNAME/APPLE_NOTARIZE_PASSWORD/APPLE_TEAM_ID)." >&2
            exit 1
          fi
          if [ "$HAS_APPLE_SECRET" = "true" ] || [ "$IS_RELEASE" = "true" ]; then
            ASSET_NAME="${BASE_NAME}.zip"
          else
            ASSET_NAME="${BASE_NAME}-unsigned.zip"
          fi

          BUNDLE_ROOT="dist/macos/${BASE_NAME}"
          BIN_DIR="${BUNDLE_ROOT}/bin"
          LIBEXEC_DIR="${BUNDLE_ROOT}/libexec/chiavdf"
          mkdir -p "$BIN_DIR" "$LIBEXEC_DIR"

          cp src/hw_vdf_client "$BIN_DIR/"
          cp src/emu_hw_vdf_client "$BIN_DIR/"
          cp src/hw_test "$BIN_DIR/"
          cp src/emu_hw_test "$BIN_DIR/"
          cp src/vdf_client "$BIN_DIR/"
          cp src/vdf_bench "$BIN_DIR/"

          cp src/hw/libft4222/libftd2xx.dylib "$LIBEXEC_DIR/"
          cp src/hw/libft4222/libft4222.1.4.4.190.dylib "$LIBEXEC_DIR/"
          ln -sf "libft4222.1.4.4.190.dylib" "$LIBEXEC_DIR/libft4222.dylib"

          dylib_files=(
            "$LIBEXEC_DIR/libftd2xx.dylib"
            "$LIBEXEC_DIR/libft4222.1.4.4.190.dylib"
          )
          sign_targets=()
          for exe in "$BIN_DIR/"*; do
            sign_targets+=("$exe")
          done
          for dylib in "${dylib_files[@]}"; do
            sign_targets+=("$dylib")
          done

          for exe in "$BIN_DIR/"*; do
            EXE_RPATHS="$(otool -l "$exe" | awk '
              $1 == "cmd" && $2 == "LC_RPATH" { in_rpath = 1; next }
              in_rpath && $1 == "path" { print $2; in_rpath = 0 }
            ')"
            if printf '%s\n' "$EXE_RPATHS" | grep -Fxq "@executable_path/hw/libft4222"; then
              install_name_tool -delete_rpath "@executable_path/hw/libft4222" "$exe"
            fi
            if ! printf '%s\n' "$EXE_RPATHS" | grep -Fxq "@loader_path/../libexec/chiavdf"; then
              install_name_tool -add_rpath "@loader_path/../libexec/chiavdf" "$exe"
            fi
          done

          for exe in "$BIN_DIR/"*; do
            otool -L "$exe"
            otool -l "$exe" | grep -F "@loader_path/../libexec/chiavdf"
            if otool -L "$exe" | grep -Eq "${GITHUB_WORKSPACE}|/Users/|/private/var/folders"; then
              echo "Found non-portable absolute library path in ${exe}" >&2
              exit 1
            fi
            if otool -l "$exe" | awk '
              $1 == "cmd" && $2 == "LC_RPATH" { in_rpath = 1; next }
              in_rpath && $1 == "path" { print $2; in_rpath = 0 }
            ' | grep -Eq "^(${GITHUB_WORKSPACE}|/Users/|/private/var/folders)"; then
              echo "Found non-portable absolute rpath in ${exe}" >&2
              exit 1
            fi
          done

          SIGNING_STATUS="unsigned (no Apple signing secrets available)"
          CODESIGN_SUMMARY_PATH="dist/macos/${BASE_NAME}.codesign-summary.txt"
          if [ "$HAS_APPLE_SECRET" = "true" ]; then
            SIGNING_IDENTITY="$(security find-identity -v -p codesigning | grep 'Developer ID Application' | awk -F\" 'NR==1{print $2}')"
            if [ -z "$SIGNING_IDENTITY" ]; then
              echo "No Developer ID Application identity found after certificate import." >&2
              exit 1
            fi

            is_valid_dev_id_signature() {
              local path="$1"
              local details
              if ! codesign --verify --strict --verbose=2 "$path" >/dev/null 2>&1; then
                return 1
              fi
              details="$(codesign -dv "$path" 2>&1 || true)"
              if printf '%s\n' "$details" | grep -Fq "Authority=Developer ID Application"; then
                return 0
              fi
              # Some runners may omit Authority lines in codesign -dv output.
              # Treat a strict-valid signature with a populated TeamIdentifier
              # as acceptable for Developer ID verification.
              if printf '%s\n' "$details" | grep -Eq '^TeamIdentifier=[^[:space:]]+' && ! printf '%s\n' "$details" | grep -Fq 'TeamIdentifier=not set'; then
                return 0
              fi
              return 1
            }

            echo "Checking FTDI dylib signatures before signing..."
            for dylib in "${dylib_files[@]}"; do
              if is_valid_dev_id_signature "$dylib"; then
                echo "FTDI dylib already has a valid Developer ID signature: $dylib"
              else
                echo "FTDI dylib needs signing: $dylib"
              fi
            done

            for target in "${sign_targets[@]}"; do
              if is_valid_dev_id_signature "$target"; then
                echo "Already signed with Developer ID: $target"
                continue
              fi
              codesign --force --timestamp --options runtime --sign "$SIGNING_IDENTITY" "$target"
            done

            echo "Verifying all bundled Mach-O binaries are signed..."
            for target in "${sign_targets[@]}"; do
              if ! is_valid_dev_id_signature "$target"; then
                echo "Unsigned or invalid Developer ID signature: $target" >&2
                codesign -dv "$target" 2>&1 || true
                exit 1
              fi
            done
            : > "$CODESIGN_SUMMARY_PATH"
            printf "codesign -dv summary for %s\n\n" "$BASE_NAME" >> "$CODESIGN_SUMMARY_PATH"
            echo "codesign -dv summary (post-sign verification):"
            for target in "${sign_targets[@]}"; do
              printf "==== %s ====\n" "$target" | tee -a "$CODESIGN_SUMMARY_PATH"
              codesign -dv "$target" 2>&1 | grep -E '^(Identifier=|Format=|CodeDirectory v=|Authority=|TeamIdentifier=|Timestamp=)' | tee -a "$CODESIGN_SUMMARY_PATH"
              echo | tee -a "$CODESIGN_SUMMARY_PATH"
            done

            (cd dist/macos && ditto -c -k --keepParent "${BASE_NAME}" "${ASSET_NAME}")
            if [ "${NOTARIZE}" = "true" ]; then
              if ! xcrun notarytool submit "dist/macos/${ASSET_NAME}" --apple-id "$APPLE_NOTARIZE_USERNAME" --password "$APPLE_NOTARIZE_PASSWORD" --team-id "$APPLE_TEAM_ID" --wait; then
                echo "Notarization failed for dist/macos/${ASSET_NAME}" >&2
                exit 1
              fi
              SIGNING_STATUS="signed + notarized"
            else
              if [ "$REQUEST_NOTARIZE" = "true" ]; then
                echo "Build reached unexpected state: notarization was requested but not enabled." >&2
                exit 1
              fi
              SIGNING_STATUS="signed (notarization skipped for non-release run)"
            fi
          else
            if [ "$IS_RELEASE" = "true" ]; then
              echo "Release build reached unexpected state: bundle was not signed." >&2
              exit 1
            fi
            (cd dist/macos && ditto -c -k --keepParent "${BASE_NAME}" "${ASSET_NAME}")
          fi

          printf "macOS %s release bundle status: %s\n" "$MACOS_ARCH" "$SIGNING_STATUS" > "dist/macos/${BASE_NAME}.signing-status.txt"
          shasum -a 256 "dist/macos/${ASSET_NAME}" | awk '{print $1}' > "dist/macos/${ASSET_NAME}.sha256"
          if [ "$IS_RELEASE" = "true" ]; then
            if [ "$MACOS_ARCH" = "arm64" ]; then
              BREW_ARCH="arm64"
            else
              BREW_ARCH="amd64"
            fi
            BREW_ASSET_NAME="chiavdf-darwin-${BREW_ARCH}.zip"
            cp "dist/macos/${ASSET_NAME}" "dist/macos/${BREW_ASSET_NAME}"
            cp "dist/macos/${ASSET_NAME}.sha256" "dist/macos/${BREW_ASSET_NAME}.sha256"
          fi

      - name: Upload macOS brew bundle artifact
        if: startsWith(matrix.os, 'macos') && matrix.config == 'optimized=1'
        uses: actions/upload-artifact@v6
        with:
          name: ${{ matrix.os == 'macos-13-arm64' && 'macos-arm64-brew-bundle' || 'macos-intel-brew-bundle' }}
          path: |
            dist/macos/*.zip
            dist/macos/*.sha256
            dist/macos/*.signing-status.txt
            dist/macos/*.codesign-summary.txt

      - name: Upload binaries artifact (Ubuntu)
        if: startsWith(matrix.os, 'ubuntu') && matrix.config == 'optimized=1'
        uses: actions/upload-artifact@v6
        with:
          name: binaries-${{ matrix.config }}-${{ matrix.os }}
          path: |
            src/vdf_client
            src/vdf_bench
            src/1weso_test
            src/2weso_test
            src/prover_test
            src/emu_hw_test
            src/hw_test
            src/emu_hw_vdf_client
            src/hw_vdf_client
            ${{ matrix.os == 'ubuntu-24.04-arm' && 'src/hw/libft4222/build-arm-v8/libft4222.so' || 'src/hw/libft4222/build-x86_64/libft4222.so' }}

      - name: Upload binaries artifact (macOS)
        if: startsWith(matrix.os, 'macos') && matrix.config == 'optimized=1'
        uses: actions/upload-artifact@v6
        with:
          name: binaries-${{ matrix.config }}-${{ matrix.os }}
          path: |
            src/vdf_client
            src/vdf_bench
            src/1weso_test
            src/2weso_test
            src/prover_test
            src/emu_hw_test
            src/hw_test
            src/emu_hw_vdf_client
            src/hw_vdf_client
            src/hw/libft4222/*.dylib

      - name: Upload binaries artifact (Windows)
        if: matrix.os == 'windows-latest' && matrix.config == 'optimized=1'
        uses: actions/upload-artifact@v6
        with:
          name: binaries-${{ matrix.config }}-${{ matrix.os }}
          path: |
            build/vdf_client.exe
            build/vdf_bench.exe
            build/1weso_test.exe
            build/2weso_test.exe
            build/prover_test.exe
            build/emu_hw_test.exe
            build/hw_test.exe
            build/emu_hw_vdf_client.exe
            build/hw_vdf_client.exe
            src/hw/libft4222/*.dll
            src/hw/libft4222/*.lib
            mpir_gc_x64/*.dll

      - name: Assemble Ubuntu .deb (same runner as build)
        if: startsWith(matrix.os, 'ubuntu') && matrix.config == 'optimized=1'
        env:
          INSTALLER_VERSION: "${{ github.event_name == 'release' && github.event.release.tag_name || format('0.0.1-{0}', github.run_id) }}"
          PLATFORM: ${{ matrix.os == 'ubuntu-24.04-arm' && 'arm64' || 'amd64' }}
          LIBFT4222_DIR: ${{ matrix.os == 'ubuntu-24.04-arm' && 'build-arm-v8' || 'build-x86_64' }}
        run: |
          pip install jinjanator
          CLI_DEB_BASE="chiavdf_$INSTALLER_VERSION-1_$PLATFORM"
          mkdir -p "dist/$CLI_DEB_BASE/usr/bin"
          mkdir -p "dist/$CLI_DEB_BASE/usr/lib"
          mkdir -p "dist/$CLI_DEB_BASE/DEBIAN"
          mkdir -p "dist/$CLI_DEB_BASE/etc/udev/rules.d"
          j2 -o "dist/$CLI_DEB_BASE/DEBIAN/control" assets/deb/control.j2

          cp src/vdf_client dist/$CLI_DEB_BASE/usr/bin/
          cp src/vdf_bench dist/$CLI_DEB_BASE/usr/bin/
          cp src/emu_hw_test dist/$CLI_DEB_BASE/usr/bin/
          cp src/hw_test dist/$CLI_DEB_BASE/usr/bin/
          cp src/hw_vdf_client dist/$CLI_DEB_BASE/usr/bin/
          cp src/emu_hw_vdf_client dist/$CLI_DEB_BASE/usr/bin/
          cp "src/hw/libft4222/$LIBFT4222_DIR/libft4222.so" dist/$CLI_DEB_BASE/usr/lib/
          echo 'SUBSYSTEM=="usb", ATTRS{idVendor}=="0403", ATTRS{idProduct}=="601c", MODE="0666"' > dist/$CLI_DEB_BASE/etc/udev/rules.d/99-chiavdf.rules
          dpkg-deb --build --root-owner-group "dist/$CLI_DEB_BASE"

      - name: Upload Ubuntu installer
        if: startsWith(matrix.os, 'ubuntu') && matrix.config == 'optimized=1'
        uses: actions/upload-artifact@v6
        with:
          name: installer-${{ matrix.os }}
          path: dist/*.deb

      - name: Upload release artifacts
        if: startsWith(matrix.os, 'ubuntu') && matrix.config == 'optimized=1' && github.event_name == 'release'
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          RELEASE_TAG: ${{ github.event.release.tag_name }}
        run: |
          gh release upload \
            --clobber \
            $RELEASE_TAG \
            dist/*.deb

      - name: Upload macOS release artifacts
        if: startsWith(matrix.os, 'macos') && matrix.config == 'optimized=1' && github.event_name == 'release'
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          RELEASE_TAG: ${{ github.event.release.tag_name }}
        run: |
          shopt -s nullglob
          release_files=(
            dist/macos/*.zip
            dist/macos/*.sha256
            dist/macos/*.signing-status.txt
            dist/macos/*.codesign-summary.txt
          )
          if [ "${#release_files[@]}" -eq 0 ]; then
            echo "No macOS release artifacts found to upload" >&2
            exit 1
          fi
          gh release upload \
            --clobber \
            "$RELEASE_TAG" \
            "${release_files[@]}"

  trigger-repo-update:
    name: Trigger repo update
    runs-on: ubuntu-latest
    needs: [build]
    if: github.event_name == 'release'
    steps:
      - uses: actions/checkout@v6
        with:
          fetch-depth: 1

      - uses: Chia-Network/actions/github/jwt@main

      - name: Build Homebrew release metadata
        id: brew_metadata
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          RELEASE_TAG: ${{ github.event.release.tag_name }}
        run: |
          set -euo pipefail
          BREW_TMP_DIR="${RUNNER_TEMP}/brew-release-assets"
          mkdir -p "$BREW_TMP_DIR"
          gh release download "$RELEASE_TAG" --dir "$BREW_TMP_DIR" --pattern "chiavdf-darwin-amd64.zip.sha256" --pattern "chiavdf-darwin-arm64.zip.sha256"
          AMD64_SHA256="$(awk '{print $1}' "$BREW_TMP_DIR/chiavdf-darwin-amd64.zip.sha256")"
          ARM64_SHA256="$(awk '{print $1}' "$BREW_TMP_DIR/chiavdf-darwin-arm64.zip.sha256")"
          if ! [[ "$AMD64_SHA256" =~ ^[0-9a-f]{64}$ ]]; then
            echo "Invalid amd64 sha256 in release metadata: $AMD64_SHA256" >&2
            exit 1
          fi
          if ! [[ "$ARM64_SHA256" =~ ^[0-9a-f]{64}$ ]]; then
            echo "Invalid arm64 sha256 in release metadata: $ARM64_SHA256" >&2
            exit 1
          fi
          AMD64_URL="https://github.com/${GITHUB_REPOSITORY}/releases/download/${RELEASE_TAG}/chiavdf-darwin-amd64.zip"
          ARM64_URL="https://github.com/${GITHUB_REPOSITORY}/releases/download/${RELEASE_TAG}/chiavdf-darwin-arm64.zip"
          JSON_DATA="$(printf '{"release_version":"%s"}' "$RELEASE_TAG")"
          echo "json_data=${JSON_DATA}" >> "$GITHUB_OUTPUT"

      - name: Trigger repo update
        uses: Chia-Network/actions/github/glue@main
        with:
          json_data: ${{ steps.brew_metadata.outputs.json_data }}
          glue_url: ${{ secrets.GLUE_API_URL }}
          glue_project: "chiavdf"
          glue_path: "trigger"
